\localauthor{Thomas Kirz}

Im Folgenden wird erklärt, wie verschiedene Sicherheitsangriffe verhindert und Sicherheitsrisiken ausgeschlossen werden.

\subsection{Cross Site Scripting (XSS)}\label{subsec:xss}
Da JSF components für die HTML-Ausgabe verwendet werden, bereinigt JSF alle Nutzereingaben.
Zum Beispiel werden also \code{'<'} und \code{'>'} durch \code{'\&lt;'} und \code{'\&gt;'} ersetzt und Nutzereingaben können keine HTML-Tags in der Ausgabe erstellen.
Dadurch wird XSS bzw.\ HTML-Injection unmöglich.
Auch JavaScript kann so nicht injected werden, da sich JavaScript-Code in einem HTML-Tag (\code{<script>}) befinden müsste.

\subsection{SQL-Injection}\label{subsec:sql-injection}
Für SQL-Code werden \code{PreparedStatements} benutzt, damit die SQL-Statements ohne von Nutzereingaben abhängige Parameter vorkompiliert werden.
Die Parameter werden dann an die Datenbank gesendet und von ihr getrennt vom Code als Daten betrachtet.
Die Ausführung des Statements kann also nicht durch die Nutzereingaben modifiziert werden und eine SQL-Injection wird verhindert

\subsection{Session Hijacking \& Fixation}\label{subsec:session-hijacking}
In der \code{web.xml}-Datei ist ein Timeout für Sessions konfigurierbar.
Dieser wirkt Session Hijacking sowie unerwünschten physischen Zugriffen auf den Browser des Clients entgegen.
JSF setzt für das Session-Cookie standardmäßig das \code{http-only}-Flag, damit kann darauf nicht mit JavaScript zugegriffen werden und Hijacking wird erschwert.

Nach jeder Anmeldung wird die Session verworfen und neu generiert mit
{\small
\begin{lstlisting}
FacesContext.getCurrentInstance().getExternalContext()
    .getRequest().changeSessionId()
\end{lstlisting}
}
Nach einer Authentifizierung bleibt also keine alte Session bestehen und \emph{Session-Fixation}-Attacken werden verhindert.

\subsection{Passwörter}\label{subsec:passwords}
Passwörter werden mit der modernen und sicheren PBKDF2-Funktion gehasht.
Dabei wird für jedes Passwort ein eigener zufällig generierter Salt benutzt, welcher mit dem Hash in der Datenbank gespeichert wird.
Eingegebene Passwörter werden so früh wie möglich gehasht, damit die Klartextpasswörter eine minimale Lebenszeit auf dem Server haben.
Für das Generieren eins Salts und das Hashing bietet die Klasse \code{Hashing} aus \code{de.java.business.util}
Methoden an.
Sie verwendet die robuste \code{javax.crypto}-Bibliothek.

Um das Erraten von Passwörtern durch Brute-Force-Attacken o.ä.\ zu erschweren, müssen Passwörter 8--100 Zeichen lang sein und Groß- und Kleinbuchstaben, Zahlen und Sonderzeichen enthalten.

\subsection{Insecure Direct Object Reference}\label{subsec:idor}
Beim Aufruf von Submission- und Profilseiten werden URL-Parameter benutzt, um die jeweilige Einreichung bzw\. Profil zu identifizieren.
Damit nicht die dafür intern in der Datenbank verwendeten IDs an die Öffentlichkeit (oder einen potentiellen Angreifer) gelangen, werden diese IDs vor der Ausgabe gehasht.
Dafür wird die Klasse \code{Hashing} aus \code{de.java.business.util} benutzt.
Dafür wird ein Hash benutzt, der beim ersten Systemstart generiert und in der Konfigurationsdatei gespeichert wird.
Damit kann von einem Hash nicht auf eine andere ID bzw.\ dessen Hash geschlossen werden.

Unsere Zugangskontrolle \todo{link} sorgt dafür, dass auch bei Erfahren einer ID auf keine Ressourcen illegal zugegriffen werden könnte.

\subsection{Information Leakage}\label{subsec:information-leakage}
Alle Informationen über das System, die nach außen gelangen, können Angreifern helfen.
Dazu gehören Details über die technische Umgebung und verwendete Software des Systems, interne Fehlermeldungen und Implementierungsdetails.
Folgende Maßnahmen werden ergriffen, um Leakage solcher Informationen zu verhindern.
Fehlermeldungen zeigen im Produktionsmodus keine Stacktraces an, sondern eigene Fehlermeldungen, die nur Informationen enthalten, die für den Endnutzer relevant sind.
Wir verwenden eigene Fehlerseiten bei Exceptions und ersetzen die 404-Seite von JSF durch unsere eigene wie folgt in der web.xml-Datei:
    {\small
\begin{lstlisting}
<error-page>
    <error-code>404</error-code>
    <location>/</location>
</error-page>
\end{lstlisting}\todo{location}
}
Dadurch ist nicht ersichtlich, dass wir JSF/Mojarra verwenden.
Das wird auch durch die Verwendung von .xhtml-Dateiendungen für unsere Facelets und Ersetzen des Bezeichners \code{JSESSONID} für Session-Cookies und URL-Rewriting in der web.xml-Datei verborgen:
    {\small
\begin{lstlisting}
<session-config>
    <cookie-config>
        <name>sesssionid</name>
    </cookie-config>
</session-config>
\end{lstlisting}
}